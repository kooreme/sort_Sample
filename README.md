# ソートサンプル
## 実装ソート
* ヒープソート
* マージソート

## 各ソートの好きな点について
### ヒープソート

私の中ではあらゆる面でメリットの多い「優等生」であり、制約がなければ大抵の場合これが良いと思っています。

ヒープソートの良さは **「配列格納式ヒープ木というデータ構造の良さ」** と、 **「ヒープソート自体の良さ」** の2点から成り立ちます。

#### 配列格納式ヒープ木というデータ構造の良さ

視覚的なヒープ木をそのままメモリ構造に落とし込むだけでは、次の値を指すメモリアドレスの保存が必要なところが欠点だと思います。

> メモリ空間が連続的でない点も考えましたが、私の場合は超高速化した現代のコンピュータで、かつアプリケーション層での開発ばかりしていたため、そのデメリットをあまり感じたことがありません。）

その欠点を解決するのが、配列だけでヒープ木を論理的に構成するアイデアでした。

**要素番号を定式に当てはめるだけで自動的に親子や兄弟要素の番号を取得できる**という点が、まるで魔法のような解決策だと思いました。

余計な変数の保存もなく、言語によりますがおおよその場合データは連続的。更に実装も単純と、調べて考察するほど「ヒープ木すごいな」という感想でした。

配列で表せるので外部へのデータ出力でも一切の苦労がありません。

構築済みのヒープ木であれば、例えばJSONとしてシリアライズしても、デシリアライズですぐに元のメモリ空間と同等に戻せます。しかも文字数的にも最低限で、保存するデータ量も小さく済みます。メモリアドレスの保存が必要な構造ではこうは行きません。

今回は「ソート」というテーマでしたが、検索や更新なども含めて様々な応用ができるところが非常に魅力的だと思いました。


#### ヒープソート自体の良さ

ヒープ木からソートする場合、配列の先頭と末尾の値を交換することで行います。

一切の無駄がない、本当にスマートな実現方法だと思いました。

ヒープソートのソート作業を概念的に表すと、

1. ヒープ木の「根」を取り除く
2. 取り除かれた「根」を別のところに記録しておく
3. 再度ヒープ木を構築し直す

という３段階の作業が必要になります。

本来なら3つの作業はまるで別物ですし、2.で必要な記録領域を作っておく必要あるように感じるのですが……。

**「配列からデータ取り除いたなら、末尾空白だよね？ならそこに記録しておけば解決でしょ」** というスマートさにしびれました。

1.と2.の作業は`swap()`で実現でき、3.のヒープ木の構築も、`swap()`の結果として根に最大値ではない値が入ったために、`downheap()`が正しく発動できるという一石三鳥の解決策だと思いました。

結果として余計な記憶領域は`swap()`に必要な一時保存変数1つで済むという省スペースぶり。

高速かつ省スペースで、一切無駄のないアルゴリズムであると思います。

今回自身で調べながら実装したことで、その思いを更に確固たるものにしました。

*****

### マージソート

直感に反して **「なんでこれで早く整列できるのだろう？」** という驚きを与えてくれるソートだと思います。

マージソートの概念としては、すべての要素を「トーナメント表」のように個人戦単位に分割した後、各要素同士で戦わせて優劣をつけるような方法だと認識しています。

計算すると計算回数は確かに減っていることはわかるのですが、見た目の直感と反するところがとても面白いと感じます。

重複する値が含まれていても問題なく動作するところもメリットで、独自実装する際にも使う場面を選ばないのは非常に嬉しいです。

一方で、現代のような高性能・高容量なメモリやストレージがあって、初めて可能なソートであるとも感じました。

再帰で呼び出す度に記憶領域が必要なところはマイナスだと考えます。

> In Place マージソートの存在もありましたが、スキル不足のため実装を断念しました……。もう少し勉強します……。

「高速ですが広いスペースを必要とする」点で、ヒープソートからは一歩劣るという印象です。

それでも、トーナメント表のように分割してから作業するだけで早くなるという点の驚きが心地よいため、好きなソートとして選択しました。
